# Условия по полисам ОСАГО

- **Обновление условий:**  
  Страховые компании обновляют условия по полисам ОСАГО не чаще двух раз в год, что позволяет заранее подготовить и систематизировать информацию.

- **База данных предложений:**  
  Создаётся база данных, учитывающая наиболее популярные запросы, такие как:
  - Средний возраст и водительский стаж клиентов;
  - Популярные марки автомобилей;
  - Географическое распределение клиентов по городам и регионам.

# Архитектура решения

## 1. Реализация osago-aggregator

- **Взаимодействие через брокер сообщений:**  
  Сервисы `core-app` и `osago-aggregator` обмениваются данными через брокер сообщений для обеспечения мгновенного отображения информации в реальном времени.

- **Публикация событий:**  
  При получении данных от различных источников `osago-aggregator` публикует событие, на которое подписан `core-app`.

- **Использование Kafka:**  
  В качестве брокера сообщений предлагается использовать Apache Kafka.

- **Long Polling:**  
  Функциональность оформления полиса ОСАГО реализуется с использованием технологии Long Polling, что позволяет получать обновления практически в реальном времени.  
  Пример: статус оформления запрашивается каждые 5-10 секунд с максимальным временем ожидания ответа в 60 секунд, что зависит от API внешних сервисов.

## 2. Хранилище данных

- **Отдельная база для osago-aggregator:**  
  Создаётся специальная база данных для хранения актуальных предложений по страховкам ОСАГО от партнерских компаний.

- **Периодическое обновление:**  
  База данных обновляется, например, раз в месяц, чтобы всегда предоставлять свежие и востребованные предложения.

## 3. Кэширование

- **Ускорение обработки:**  
  Для повышения скорости обработки запросов используется кэширование (например, с помощью Redis), что позволяет снизить нагрузку на основную базу данных и уменьшить время отклика.

## 4. Паттерны отказоустойчивости

- **Rate Limiter:**  
  Применяется для контроля нагрузки на приложение `core-app` посредством ограничения количества запросов от одного пользователя.

- **Resilient Fetch с таймаутом:**  
  Если данные не обнаружены в нашей базе, запросы перенаправляются к сторонним API. При этом применяется паттерн, который повторяет запросы в случае неудачи и поддерживает стратегию фейловера (например, переключение на резервный адрес) с максимальной задержкой 60 секунд.

## 5. Возможные проблемы

- **Дублирование записей:**  
  При работе сервиса на нескольких инстансах существует риск дублирования записей в базе данных, если разные инстансы обрабатывают один и тот же запрос.

- **Решение проблемы:**  
  Для устранения дублирования рекомендуется периодически запускать скрипт для оптимизации и очистки дублирующихся записей.


[ссылка на решение drawio]: https://drive.google.com/file/d/1efPLl_kf0a3Fvyro9oMHPXhL9r6Xjb6a/view?usp=sharing